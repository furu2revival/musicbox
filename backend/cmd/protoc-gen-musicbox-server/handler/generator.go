package handler

import (
	"runtime/debug"
	"strings"

	"github.com/furu2revival/musicbox/protobuf/custom_option"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

var (
	ctxIdent             = protogen.GoImportPath("context").Ident("Context")
	connectRequestIdent  = protogen.GoImportPath("connectrpc.com/connect").Ident("Request")
	connectResponseIdent = protogen.GoImportPath("connectrpc.com/connect").Ident("Response")
	methodInfoIdent      = protogen.GoImportPath("github.com/furu2revival/musicbox/app/infrastructure/connect/aop").Ident("MethodInfo")
	reqIdent             = protogen.GoImportPath("github.com/furu2revival/musicbox/app/infrastructure/connect/aop").Ident("Request")
)

type Config struct {
	MethodOptExt protoreflect.ExtensionType

	MethodOptIdent    protogen.GoIdent
	MethodOptExtIdent protogen.GoIdent
	MethodErrDefIdent protogen.GoIdent
	ProxyIdent        protogen.GoIdent
}

type MethodOption interface {
	GetMethodErrorDefinitions() []*custom_option.MethodErrorDefinition
}

type Generator[MethodOpt MethodOption] struct {
	conf Config
}

func NewGenerator[MethodOpt MethodOption](conf Config) Generator[MethodOpt] {
	return Generator[MethodOpt]{conf: conf}
}

func (g Generator[MethodOpt]) Generate(plugin *protogen.Plugin, file *protogen.File) error {
	buildInfo, _ := debug.ReadBuildInfo()
	filename := file.GeneratedFilenamePrefix + ".musicbox.go"
	gf := plugin.NewGeneratedFile(filename, file.GoImportPath)
	gf.P("// Code generated by ", buildInfo.Path, ". DO NOT EDIT.")
	gf.P("// source: ", file.Desc.Path())
	gf.P()
	gf.P("package ", file.GoPackageName)
	gf.P()
	for _, service := range file.Services {
		g.generateHandler(gf, service)
		gf.P()
		for _, method := range service.Methods {
			g.generateMethodErrorType(gf, service, method)
			gf.P()
		}

		g.generateHandlerConstructor(gf, service, file)
		gf.P()
		g.generateHandlerImpl(gf, service)
		gf.P()
	}
	return nil
}

func (g Generator[MethodOpt]) generateHandler(gf *protogen.GeneratedFile, service *protogen.Service) {
	gf.P(service.Comments.Leading, "type musicbox_", service.GoName, "Handler interface {")
	for _, method := range service.Methods {
		gf.P(method.Comments.Leading, method.GoName, "(ctx ", ctxIdent, ", req *", reqIdent, "[*", method.Input.GoIdent, "]) (*", method.Output.GoIdent, ", error)")

		opt := g.toMethodOpt(method)
		if len(opt.GetMethodErrorDefinitions()) != 0 {
			gf.P(method.GoName, "Errors(errs *", errorsName(service, method), ")")
		}
		gf.P()
	}
	gf.P("}")
}

func (g Generator[MethodOpt]) generateHandlerImpl(gf *protogen.GeneratedFile, service *protogen.Service) {
	methodInvokeIdent := protogen.GoImportPath("github.com/furu2revival/musicbox/app/infrastructure/connect").Ident("Invoke")
	responseConstructorIdent := protogen.GoImportPath("connectrpc.com/connect").Ident("NewResponse")

	gf.P("type ", handlerImplName(service), " struct {")
	gf.P("handler musicbox_", service.GoName, "Handler")
	gf.P("proxy ", g.conf.ProxyIdent)
	gf.P("methodInfo [", len(service.Methods), "]*", methodInfoIdent)
	gf.P("}")
	gf.P()
	for i, method := range service.Methods {
		gf.P("func (h ", handlerImplName(service), ") ", method.GoName, "(ctx ", ctxIdent, ", req *", connectRequestIdent, "[", method.Input.GoIdent, "]) (*", connectResponseIdent, "[", method.Output.GoIdent, "], error) {")
		gf.P("res, err := ", methodInvokeIdent, "(ctx, req.Msg, req.Header(), h.methodInfo", "[", i, "], h.handler.", method.GoName, ", h.proxy)")
		gf.P("if err != nil {")
		gf.P("return nil, err")
		gf.P("}")
		gf.P("return ", responseConstructorIdent, "(res), nil")
		gf.P("}")
		gf.P()
	}
}

func (g Generator[MethodOpt]) generateHandlerConstructor(gf *protogen.GeneratedFile, service *protogen.Service, file *protogen.File) {
	extIdent := protogen.GoImportPath("google.golang.org/protobuf/proto").Ident("GetExtension")
	newMethodInfoIdent := protogen.GoImportPath("github.com/furu2revival/musicbox/app/infrastructure/connect/aop").Ident("NewMethodInfo")

	gf.P("func New", service.GoName, "Handler(handler musicbox_", service.GoName, "Handler, proxy ", g.conf.ProxyIdent, ") ", handlerImplName(service), " {")
	gf.P("service := ", file.GoDescriptorIdent, ".Services().ByName(\"", service.GoName, "\")")
	gf.P("causes := [", len(service.Methods), "]map[error]*", g.conf.MethodErrDefIdent, "{", strings.Repeat("{},", len(service.Methods)), "}")
	gf.P("methodOpts := [", len(service.Methods), "]*", g.conf.MethodOptIdent, "{}")
	gf.P("for i, m := 0, service.Methods(); i < ", len(service.Methods), "; i++ {")
	gf.P("methodOpts[i] = ", extIdent, "(m.Get(i).Options(), ", g.conf.MethodOptExtIdent, ").(*", g.conf.MethodOptIdent, ")")
	gf.P("}")
	for i, method := range service.Methods {
		opt := g.toMethodOpt(method)
		if len(opt.GetMethodErrorDefinitions()) == 0 {
			continue
		}
		gf.P("handler.", method.GoName, "Errors(&", errorsName(service, method), "{")
		for j, errDef := range opt.GetMethodErrorDefinitions() {
			gf.P(errCodeName(errDef), ": methodOpts[", i, "].GetMethodErrorDefinitions()[", j, "],")
		}
		gf.P("causes: causes[", i, "],")
		gf.P("})")
	}
	gf.P("methodInfo := [", len(service.Methods), "]*", methodInfoIdent, "{")
	for i := range service.Methods {
		gf.P(newMethodInfoIdent, "(methodOpts[", i, "], causes[", i, "]),")
	}
	gf.P("}")
	gf.P("return ", handlerImplName(service), "{handler: handler, proxy: proxy, methodInfo: methodInfo}")
	gf.P("}")
}

func (g Generator[MethodOpt]) generateMethodErrorType(gf *protogen.GeneratedFile, service *protogen.Service, method *protogen.Method) {
	opt := g.toMethodOpt(method)
	if len(opt.GetMethodErrorDefinitions()) == 0 {
		return
	}

	gf.P("type ", errorsName(service, method), " struct {")
	for _, errDef := range opt.GetMethodErrorDefinitions() {
		gf.P("// ", errDef.GetMessage())
		gf.P(errCodeName(errDef), " *", g.conf.MethodErrDefIdent)
	}
	gf.P()
	gf.P("causes map[error]*", g.conf.MethodErrDefIdent)
	gf.P("}")
	gf.P()

	gf.P("func (e *", errorsName(service, method), ") Map(from error, to *", g.conf.MethodErrDefIdent, ") {")
	gf.P("e.causes[from] = to")
	gf.P("}")
}

func (g Generator[MethodOpt]) toMethodOpt(method *protogen.Method) MethodOpt {
	//nolint:forcetypeassert
	return proto.GetExtension(method.Desc.Options(), g.conf.MethodOptExt).(MethodOpt)
}

func handlerImplName(service *protogen.Service) string {
	return "musicbox_" + service.GoName + "HandlerImpl"
}

func errorsName(service *protogen.Service, method *protogen.Method) string {
	return service.GoName + method.GoName + "Errors"
}

func errCodeName(errDef *custom_option.MethodErrorDefinition) string {
	return strings.TrimPrefix(errDef.GetCode().String(), "METHOD_")
}
