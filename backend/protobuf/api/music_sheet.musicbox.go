// Code generated by github.com/furu2revival/musicbox/cmd/protoc-gen-musicbox-server. DO NOT EDIT.
// source: api/music_sheet.proto

package api

import (
	connect "connectrpc.com/connect"
	context "context"
	connect1 "github.com/furu2revival/musicbox/app/infrastructure/connect"
	aop "github.com/furu2revival/musicbox/app/infrastructure/connect/aop"
	custom_option "github.com/furu2revival/musicbox/protobuf/custom_option"
	proto "google.golang.org/protobuf/proto"
)

type musicbox_MusicSheetServiceHandler interface {
	GetV1(ctx context.Context, req *aop.Request[*MusicSheetServiceGetV1Request]) (*MusicSheetServiceGetV1Response, error)
	GetV1Errors(errs *MusicSheetServiceGetV1Errors)

	CreateV1(ctx context.Context, req *aop.Request[*MusicSheetServiceCreateV1Request]) (*MusicSheetServiceCreateV1Response, error)
	CreateV1Errors(errs *MusicSheetServiceCreateV1Errors)
}

type MusicSheetServiceGetV1Errors struct {
	// The music sheet does not exist.
	RESOURCE_NOT_FOUND *aop.MethodErrDefinition

	causes map[error]*aop.MethodErrDefinition
}

func (e *MusicSheetServiceGetV1Errors) Map(from error, to *aop.MethodErrDefinition) {
	e.causes[from] = to
}

type MusicSheetServiceCreateV1Errors struct {
	// The title length must be between 1 and 100.
	ILLEGAL_ARGUMENT *aop.MethodErrDefinition

	causes map[error]*aop.MethodErrDefinition
}

func (e *MusicSheetServiceCreateV1Errors) Map(from error, to *aop.MethodErrDefinition) {
	e.causes[from] = to
}

func NewMusicSheetServiceHandler(handler musicbox_MusicSheetServiceHandler, proxy aop.Proxy) musicbox_MusicSheetServiceHandlerImpl {
	service := File_api_music_sheet_proto.Services().ByName("MusicSheetService")
	causes := [2]map[error]*aop.MethodErrDefinition{{}, {}}
	methodOpts := [2]*aop.MethodOption{}
	for i, m := 0, service.Methods(); i < 2; i++ {
		methodOpts[i] = proto.GetExtension(m.Get(i).Options(), custom_option.E_MethodOption).(*aop.MethodOption)
	}
	handler.GetV1Errors(&MusicSheetServiceGetV1Errors{
		RESOURCE_NOT_FOUND: methodOpts[0].GetMethodErrorDefinitions()[0],
		causes:             causes[0],
	})
	handler.CreateV1Errors(&MusicSheetServiceCreateV1Errors{
		ILLEGAL_ARGUMENT: methodOpts[1].GetMethodErrorDefinitions()[0],
		causes:           causes[1],
	})
	methodInfo := [2]*aop.MethodInfo{
		aop.NewMethodInfo(methodOpts[0], causes[0]),
		aop.NewMethodInfo(methodOpts[1], causes[1]),
	}
	return musicbox_MusicSheetServiceHandlerImpl{handler: handler, proxy: proxy, methodInfo: methodInfo}
}

type musicbox_MusicSheetServiceHandlerImpl struct {
	handler    musicbox_MusicSheetServiceHandler
	proxy      aop.Proxy
	methodInfo [2]*aop.MethodInfo
}

func (h musicbox_MusicSheetServiceHandlerImpl) GetV1(ctx context.Context, req *connect.Request[MusicSheetServiceGetV1Request]) (*connect.Response[MusicSheetServiceGetV1Response], error) {
	res, err := connect1.Invoke(ctx, req.Msg, req.Header(), h.methodInfo[0], h.handler.GetV1, h.proxy)
	if err != nil {
		return nil, err
	}
	return connect.NewResponse(res), nil
}

func (h musicbox_MusicSheetServiceHandlerImpl) CreateV1(ctx context.Context, req *connect.Request[MusicSheetServiceCreateV1Request]) (*connect.Response[MusicSheetServiceCreateV1Response], error) {
	res, err := connect1.Invoke(ctx, req.Msg, req.Header(), h.methodInfo[1], h.handler.CreateV1, h.proxy)
	if err != nil {
		return nil, err
	}
	return connect.NewResponse(res), nil
}
